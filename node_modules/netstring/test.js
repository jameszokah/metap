var Buffer = require('buffer').Buffer;
var events = require('events');
var ns = require('./ns');

exports.nsPayloadLength = {
  'simple': function(test) {
    test.equal(ns.nsPayloadLength('30:'), 30);
    test.done();
  },
  'incomplete': function(test) {
    test.equal(ns.nsPayloadLength(''), -1);
    test.equal(ns.nsPayloadLength('30'), -1);
    test.done();
  },
  'leading zero': function(test) {
    test.equal(ns.nsPayloadLength('0:,'), 0);
    test.throws(function() {
      ns.nsPayloadLength('03:');
    }, 'Invalid netstring with leading 0');
    test.throws(function() {
      ns.nsPayloadLength('00:');
    }, 'Invalid netstring with leading 0');
    test.done();
  },
  'leading colon': function(test) {
    test.throws(function() {
      ns.nsPayloadLength(':');
    }, 'Invalid netstring with leading \':\'');
    test.throws(function() {
      ns.nsPayloadLength(':a');
    }, 'Invalid netstring with leading \':\'');
    test.done();
  },
  'invalid char': function(test) {
    test.throws(function() {
      ns.nsPayloadLength('3;');
    }, 'Unexpected character \';\' found at offset 1');
    test.throws(function() {
      ns.nsPayloadLength(';');
    }, 'Unexpected character \';\' found at offset 0');
    test.done();
  },
  'offset': function(test) {
    test.equal(ns.nsPayloadLength('xxx30', 3), -1);
    test.equal(ns.nsPayloadLength('xxx30:', 3), 30);
    test.done();
  },
  'encoding': function(test) {
    test.equal(ns.nsPayloadLength('30:', 0, 'utf8'), 30);
    test.equal(ns.nsPayloadLength(new Buffer('30:', 'utf8'), 0), 30);
    test.equal(ns.nsPayloadLength(new Buffer([0x33, 0x30, 0x3a, 0x0], 'binary'), 0), 30);
    test.done();
  }
};

exports.nsLength = {
  'simple': function(test) {
    test.equal(ns.nsLength('0:,'), 3);
    test.equal(ns.nsLength('1:q,'), 4);
    test.equal(ns.nsLength('30:'), 34);
    test.done();
  },
  'incomplete': function(test) {
    test.equal(ns.nsLength(''), -1);
    test.equal(ns.nsLength('30'), -1);
    test.done();
  },
  'encoding': function(test) {
    test.equal(ns.nsLength('1:q,', 0, 'utf8'), 4);
    test.equal(ns.nsLength(new Buffer('1:q,', 0, 'utf8')), 4);
    test.equal(ns.nsLength(new Buffer([0x33, 0x30, 0x3a, 0x0], 'binary'), 0), 34);
    test.done();
  }
};

exports.nsWriteLength = {
  'simple': function(test) {
    test.equal(ns.nsWriteLength(0), 3);
    test.equal(ns.nsWriteLength(1), 4);
    test.equal(ns.nsWriteLength(9), 12);
    test.equal(ns.nsWriteLength(10), 14);
    test.done();
  }
};

exports.nsPayload = {
  'simple': function(test) {
    test.equal(ns.nsPayload('0:,'), '');
    test.equal(ns.nsPayload('3:abc,'), 'abc');
    test.equal(ns.nsPayload(new Buffer('3:abc,')), 'abc');
    test.done();
  },
  'incomplete': function(test) {
    test.equal(ns.nsPayload(''), -1);
    test.equal(ns.nsPayload('3'), -1);
    test.equal(ns.nsPayload('3:ab'), -1);
    test.equal(ns.nsPayload('3:abc'), -1);
    test.done();
  },
  'utf8': function(test) {
    test.equal(ns.nsPayload('3:☃,'), '☃');
    test.equal(ns.nsPayload(new Buffer('3:☃,')), '☃');
    test.done();
  },
  'encoding': function(test) {
    test.equal(ns.nsPayload('3:☃,', 0, 'utf8'), '☃');
    test.equal(ns.nsPayload(new Buffer('3:☃,', 'utf8'), 0), '☃');
    test.equal(ns.nsPayload(new Buffer([0x33, 0x3a, 0x61, 0x62, 0x63, 0x2c], 'binary'), 0), 'abc');
    test.done();
  }
};

exports.nsWrite = {
  'simple': function(test) {
    test.equal(ns.nsWrite(''), '0:,');
    test.equal(ns.nsWrite('abc'), '3:abc,');
    test.equal(ns.nsWrite('a'), '1:a,');
    test.done();
  },
  'utf8': function(test) {
    test.equal(ns.nsWrite('☃'), '3:☃,');
    test.equal(ns.nsWrite(new Buffer('☃')), '3:☃,');
    test.done();
  },
  'start': function(test) {
    test.equal(ns.nsWrite('abc', 1), '2:bc,');
    test.equal(ns.nsWrite('abc', 0), '3:abc,');
    test.throws(function() {
      ns.nsWrite('abc', -1);
    }, 'payStart is out of bounds');
    // test.throws(function() {
    //   ns.nsWrite('abc', 3);
    // }, 'payStart is out of bounds');
    test.done();
  },
  'end': function(test) {
    test.equal(ns.nsWrite('abc', 0, 1), '1:a,');
    test.equal(ns.nsWrite('abc', 0, 3), '3:abc,');
    test.equal(ns.nsWrite('abc', 0, 0), '0:,');
    test.throws(function() {
      ns.nsWrite('abc', 0, -1);
    }, 'payEnd is out of bounds');
    test.throws(function() {
      ns.nsWrite('abc', 0, 4);
    }, 'payEnd is out of bounds');
    test.done();
  },
  'bufPay': function(test) {
    test.equal(ns.nsWrite(new Buffer('abc')), '3:abc,');
    test.equal(ns.nsWrite(new Buffer('abc'), 1), '2:bc,');
    test.equal(ns.nsWrite(new Buffer('abc'), 1, 2), '1:b,');
    test.done();
  },
  'bufTarget': function(test) {
    function beq(pay, payStart, payEnd, bufLen, bufOff) {
      var buf = new Buffer(ns.nsWriteLength(bufLen));
      var nsLen = ns.nsWrite.call(this, pay, payStart, payEnd, buf, bufOff)
      test.ok(nsLen >= 3);

      var bb = buf.slice(bufOff, bufOff + nsLen);
      test.equal(bb.toString(), ns.nsWrite(pay, payStart, payEnd));
    };
    beq('abc', 0, 3, 3, 0);
    beq('abc', 0, 1, 3, 0);
    beq('abc', 0, 3, 10, 1);
    test.done();
  },
  'encoding': function(test) {
    test.equal(ns.nsWrite('☃', 0, 3, null, 0, 'utf8'), '3:☃,');
    test.equal(ns.nsWrite(new Buffer('☃', 'utf8'), 0, 3, null, 0), '3:☃,');
    test.equal(ns.nsWrite(new Buffer([0x61, 0x62, 0x63], 'binary'), 0), '3:abc,');
    test.done();
  }
};

exports.Stream = {
  'simple': function(test) {
    var is  = new events.EventEmitter();
    var ins = new ns.Stream(is);

    var MSGS = [
      "abc",
      "hello world!",
      "café",
      "a",
      "b",
      "c"
    ];

    var msgsReceived = 0;
    ins.addListener('data', function(d) {
      test.equal('object', typeof d);
      test.equal(d.toString(), MSGS[msgsReceived]);
      msgsReceived++;
    });

    is.emit('data', new Buffer("3:abc,"));
    is.emit('data', new Buffer("12:hello"));
    is.emit('data', new Buffer(" world!,"));
    is.emit('data', new Buffer("5:café,"));
    is.emit('data', new Buffer("1:a,1:b,1:c,"));

    test.done();
  },
  'set encoding': function(test) {
    var is  = new events.EventEmitter();
    var ins = new ns.Stream(is);
    ins.setEncoding('utf8');

    var MSGS = [
      "a",
      "b",
      "c"
    ];

    var msgsReceived = 0;
    ins.addListener('data', function(d) {
      test.equal('string', typeof d);
      test.equal(d, MSGS[msgsReceived]);
      msgsReceived++;
    });

    is.emit('data', new Buffer("1:a,1:b,"));
    is.emit('data', new Buffer("1:c,"));

    test.done();
  }
};
